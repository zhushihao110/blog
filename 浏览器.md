## 浏览器原理

- **Browser进程**：浏览器的主进程（负责协调、主控），只有一个。
- **第三方插件进程**：每种类型的插件对应一个进程，仅当使用该插件时才创建
- **GPU进程**：最多一个，用于3D绘制等
- **浏览器渲染进程**（浏览器内核)(Renderer进程，内部是多线程的)：默认每个Tab页面一个进程，互不影响。
- **Worker/SharedWorker**，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM），JS引擎线程与worker线程间通过特定的方式通信（postMessage API）

------

### 浏览器内核

#### 浏览器渲染进程

主要作用为：页面渲染，脚本执行，事件处理等

- **GUI渲染线程**：负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等
- **事件触发线程**：管理着一个任务队列用来控制事件循环，当JS引擎执行代码块如setTimeOut时，会将对应任务添加到事件线程中
- **定时触发器线程**：传说中的setInterval与setTimeout所在线程
- **异步http请求线程**：在XMLHttpRequest在连接后是通过浏览器新开一个线程请求
- **JS引擎线程**：也称为JS内核，负责处理Javascript脚本程序， ***GUI渲染线程与JS引擎线程是互斥的***

#### Worker/SharedWorker

- JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM），

- JS引擎线程与worker线程间通过特定的方式通信（postMessage API）

------

### 从Event Loop谈JS的运行机制

#### 事件循环机制

- JS分为同步任务和异步任务
- 同步任务都在主线程上执行，形成一个执行栈
- 一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。
- 主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件

#### macrotask与microtask

- macrotask（又称之为宏任务），可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）： 主代码块，setTimeout，setInterval等
- microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务： Promise，process.nextTick， await等

执行栈-->宏任务->微任务-> 渲染：循环执行

***注意：Node环境，process.nextTick的优先级高于Promise***

